AWSTemplateFormatVersion: 2010-09-09
Description: >-
  This CF template creates a VPC infrastructure for a multi-AZ, multi-tier
  deployment of TIBCO Spotfire Data Science 6.4 on AWS. It deploys a VPC with
  bastions. **WARNING** This template creates EC2 instances and related
  resources. You will be billed for the AWS resources used if you create a stack
  from this template.
Metadata:
  'AWS::CloudFormation::Interface':
    ParameterGroups:
    - Label:
        default: Network Configuration
      Parameters:
      - VPCID
      - PrivateSubnet1ID
      - PrivateSubnet2ID
      - PublicSubnet1ID
      - PublicSubnet2ID
      - AdminConsoleAccessCIDR
    - Label:
        default: Bastion Configuration
      Parameters:
      - KeyPairName
      - BastionSecurityGroupID
    - Label:
        default: TIBCO Spotfire DS Configuration
      Parameters:
      - TSDSowner
      - TSDSInstanceName
      - TSDSInstanceType
    ParameterLabels:
      AdminConsoleAccessCIDR:
        default: Allowed Admin Web Console External Access CIDR
      BastionSecurityGroupID:
        default: Bastion Security Group ID
      KeyPairName:
        default: SSH Key Name
      TSDSowner:
        default: TSDS Instance Owner
      TSDSInstanceName:
        default: TSDS Instance Name
      TSDSInstanceType:
        default: TSDS Instance Type
      PrivateSubnet1ID:
        default: Private Subnet 1 ID
      PrivateSubnet2ID:
        default: Private Subnet 2 ID
      PublicSubnet1ID:
        default: Public Subnet 1 ID
      PublicSubnet2ID:
        default: Public Subnet 2 ID
      VPCID:
        default: VPC ID
Parameters:
  RDSUsername:
    Default: postgres_chorus
    Description: >-
      DB Username must start with a letter & no special characters(MinLength=4;MaxLength=20)
    MaxLength: '16'
    MinLength: '4'
    Type: String
  RDSPassword:
    AllowedPattern: >-
      (?=^.{6,255}$)((?=.*\d)(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[^A-Za-z0-9])(?=.*[a-z])|(?=.*[^A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9]))^.*
    ConstraintDescription: >-
      Must be 8 characters or more containing at least one uppercase letter, one
      lowercase letter, and one number.
    Default: tibcoAlpine!23
    Description: >-
      DB Password for RDS, Redshift and Portal access. Must be 8 characters or
      more containing at least one uppercase letter, one lowercase letter and
      one number. It can use any printable ASCII characters (ASCII code 33 to
      126) except ' (single quote), " (double quote) , \, /, @, or space
    MaxLength: '16'
    MinLength: '8'
    NoEcho: 'true'
    Type: String
  AdminConsoleAccessCIDR:
    AllowedPattern: ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/([0-9]|[1-2][0-9]|3[0-2]))$
    ConstraintDescription: CIDR block parameter must be in the form x.x.x.x/x
    Description: The CIDR IP range that is permitted to access the TIBCO Spotfire Data Science Web Console
      via the ELB. We recommend that you set this value to a trusted IP range.
    Type: String
  BastionSecurityGroupID:
    Description: ID of the bastion host security group to enable SSH connections (e.g.,
      sg-7f16e910)
    Type: AWS::EC2::SecurityGroup::Id
  TSDSInstanceName:
    Description: Name for the TSDS instance that is deployed to EC2
    Type: String
    Default: tsds
  TSDSInstanceType:
    AllowedValues:
      - m5.2xlarge
      - m5.4xlarge
    ConstraintDescription: Must contain valid instance type
    Default: m5.2xlarge
    Description: Type of EC2 instance for TIBCO Spotfire DS 6.4 AMI
    Type: String
  KeyPairName:
    Description: Name of an existing EC2 key pair. All instances will launch with
      this key pair.
    Type: AWS::EC2::KeyPair::KeyName
  TSDSowner:
    Description: Set Owner tag for the TIBCO Spotfire Data Science instance
    Default: tsds-owner
    Type: String
  PrivateSubnet1ID:
    Description: ID of private subnet 1 in Availability Zone 1 for the TSDS instances
      (e.g., subnet-a0246dcd)
    Type: AWS::EC2::Subnet::Id
  PrivateSubnet2ID:
    Description: ID of private subnet 2 in Availability Zone 2 for the TSDS instances
      (e.g., subnet-b1f432cd)
    Type: AWS::EC2::Subnet::Id
  PublicSubnet1ID:
    Description: ID of public subnet 1 in Availability Zone 1 for the ELB load balancer
      (e.g., subnet-9bc642ac)
    Type: AWS::EC2::Subnet::Id
  PublicSubnet2ID:
    Description: ID of public subnet 2 in Availability Zone 2 for the ELB load balancer
      (e.g., subnet-e3246d8e)
    Type: AWS::EC2::Subnet::Id
  VPCID:
    Description: ID of your existing VPC for deployment
    Type: AWS::EC2::VPC::Id
Rules:
  EFSSupportedRegionRule:
    Assertions:
    - Assert:
        Fn::Contains:
        - - us-east-1
          - us-east-2
          - us-west-2
          - us-west-1
          - eu-west-1
          - ap-southeast-2
          - ap-southeast-1
          - ap-northeast-1
          - ap-northeast-2
          - eu-central-1
        - !Ref AWS::Region
      AssertDescription: This Quick Start utilizes Amazon EFS which is only available
        in the us-east-1 (N. Virginia), us-east-2 (Ohio), us-west-1 (N. California), us-west-2 (Oregon), eu-west-1 (Ireland),
        eu-central-1 (Frankfurt), ap-northeast-1 (Tokyo), ap-northeast-2 (Seoul), and ap-southeast-2 (Sydney) regions. Please launch the stack in
        one of these regions
Mappings:
  AWSAMIRegionMap:
    us-west-1:
      '64': ami-0509ca366708b4622
    us-west-2:
      '64': ami-04c5f789ecde281b0
    us-east-1:
      '64': ami-0e057d4facc96b5d8
    ap-southeast-1:
      '64': ami-02923f8ebf2dbabb3
    eu-west-1:
      '64': ami-06442ae55a8ed81e5
Resources:
  InstanceRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - ec2.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: /
  InstanceRolePolicy:
    Type: 'AWS::IAM::Policy'
    Properties:
      PolicyName: ReportHealthPolicy
      PolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Action: autoscaling:SetInstanceHealth
          Resource:
            Fn::Sub: arn:aws:autoscaling:${AWS::Region}:${AWS::AccountId}:autoScalingGroup:*:autoScalingGroupName/${AutoScalingGroup}
      Roles:
      - !Ref InstanceRole
  InstanceProfile:
    Type: 'AWS::IAM::InstanceProfile'
    Properties:
      Path: /
      Roles:
      - !Ref InstanceRole
  DatabaseSubnetGroup:
    Type: 'AWS::RDS::DBSubnetGroup'
    Properties:
      DBSubnetGroupDescription: CloudFormation managed DB subnet group.
      SubnetIds:
        - !Ref PrivateSubnet1ID
        - !Ref PrivateSubnet2ID
  TSDSDBCluster:
    Type: 'AWS::RDS::DBCluster'
    Properties:
      Engine: aurora-postgresql
      DBClusterParameterGroupName: default.aurora-postgresql9.6
      DatabaseName: postgres_chorus
      MasterUsername: !Ref RDSUsername
      MasterUserPassword: !Ref RDSPassword
      Port: 8543
      DBSubnetGroupName: !Ref DatabaseSubnetGroup
      VpcSecurityGroupIds:
        - !Ref DBSecurityGroup
  TSDSDB:
    Type: 'AWS::RDS::DBInstance'
    Properties:
      Engine: aurora-postgresql
      DBClusterIdentifier: !Ref TSDSDBCluster
      DBSubnetGroupName: !Ref DatabaseSubnetGroup
      DBInstanceClass: db.r4.large
  DBSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      VpcId: !Ref VPCID
      GroupDescription: Enable DB port 8543
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: '8543'
        ToPort: '8543'
        SourceSecurityGroupId: !Ref TSDSSecurityGroup
  TSDSSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      VpcId: !Ref VPCID
      GroupDescription: Enable SSH access via port 22, and access to 8080 via ELB
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: '22'
        ToPort: '22'
        SourceSecurityGroupId: !Ref BastionSecurityGroupID
      - IpProtocol: tcp
        FromPort: '8080'
        ToPort: '8080'
        SourceSecurityGroupId: !Ref TSDSELBSecurityGroup
  TSDSELBSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      VpcId: !Ref VPCID
      GroupDescription: Enable access via port 8080
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: '8080'
        ToPort: '8080'
        CidrIp: !Ref AdminConsoleAccessCIDR
  MountTargetSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      VpcId: !Ref VPCID
      GroupDescription: Security group for mount target
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: '2049'
        ToPort: '2049'
        SourceSecurityGroupId: !Ref TSDSSecurityGroup
  LaunchConfiguration:
    Type: 'AWS::AutoScaling::LaunchConfiguration'
    DependsOn:
      - TSDSDB
      - TSDSDBCluster
      - TSDSFileSystem
    Properties:
      AssociatePublicIpAddress: true
      ImageId:
         Fn::FindInMap:
         - AWSAMIRegionMap
         - !Ref AWS::Region
         - '64'
      InstanceType: !Ref TSDSInstanceType
      KeyName: !Ref KeyPairName
      EbsOptimized: true
      SecurityGroups:
      - !Ref TSDSSecurityGroup
      IamInstanceProfile: !Ref InstanceProfile
      UserData: !Base64
        'Fn::Sub': |
            #!/bin/bash

            # first_run Function initializes the cluster and copies all necessary files to EFS and RDS.
            # This only needs to happen on first node.  All nodes that are auto-created should use second_run function

            # This is the check to determin if file exists.
            # if file does not exists, start first_run
            # if file exists, start second_run
            logfile=/tmp/cf.log

            echo "# Create directory to mount EFS DIR..." >> $logfile 2>&1
            # Script to configure Node 1 of TSDS 6.4
            # Create directory to mount EFS DIR
            mkdir /tsds_efs

            echo "# Mount EFS and add mount to fstab to restore on reboot..." >> $logfile 2>&1
            # Mount EFS and add mount to fstab to restore on reboot
            mount -t nfs4 -o nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2,noresvport ${TSDSFileSystem}.efs.${AWS::Region}.amazonaws.com:/ /tsds_efs >> $logfile 2>&1
            echo "${TSDSFileSystem}.efs.${AWS::Region}.amazonaws.com:/ /tsds_efs     nfs4    defaults,_netdev        0       0" >> /etc/fstab >> $logfile 2>&1

            echo "# Rename old install DIR and replace with soft link to new EFS DIR..." >> $logfile 2>&1
            # Rename old install DIR and replace with soft link to new EFS DIR
            mv /usr/local/tsds /usr/local/tsds_old
            mv /data/tsds/public /data/tsds/public_old
            mv /data/tsds/system /data/tsds/system_old
            ln -s /tsds_efs/local/tsds /usr/local/tsds
            ln -s /tsds_efs/data/tsds/public /data/tsds/public
            ln -s /tsds_efs/data/tsds/system /data/tsds/system

            echo "# Load first_run function..." >> $logfile 2>&1
            first_run() {
              echo "# Running first_run..." >> $logfile 2>&1

              # Create shared directory structure
              echo "# Creating INSTALL and DATA DIR on Amazon EFS..." >> $logfile 2>&1
              mkdir --parents /tsds_efs/local/
              mkdir --parents /tsds_efs/data/tsds/

              # Change owners to tsds
              echo "# Change Owners to tsds"
              chown tsds:tsds -R /tsds_efs

              # Copy install DIR to EFS Shared DIR
              echo "# Copy INSTALL and DATA DIR to EFS Shared DIR..." >> $logfile 2>&1
              echo "# Copy INSTALL to EFS Shared DIR..." >> $logfile 2>&1

              su -c "cp -a /usr/local/tsds_old/ /tsds_efs/local/tsds" - tsds >> $logfile 2>&1

              echo "# Copy DATA to EFS Shared DIR..." >> $logfile 2>&1

              su -c "cp -a /data/tsds/public_old/ /tsds_efs/data/tsds/public" - tsds >> $logfile 2>&1
              su -c "cp -a /data/tsds/system_old/ /tsds_efs/data/tsds/system" - tsds >> $logfile 2>&1

              # Change ownership to tsds
              echo "# Change ownership to tsds..." >> $logfile 2>&1
              chown tsds:tsds -R /tsds_efs

              # start postgres service to perform backup
              echo "# Starting Internal Postgres..." >> $logfile 2>&1
              su -c "source /usr/local/tsds/chorus_path.sh && /usr/local/tsds/chorus_control.sh start postgres" - tsds >> $logfile 2>&1

              # backup postgres and shutdown postgres
              echo "# Backup Internal Postgres..." >> $logfile 2>&1
              su -c "source /usr/local/tsds/chorus_path.sh && /usr/local/tsds/current/postgres/bin/pg_dump -Fc -p 8543 -U postgres_chorus chorus > /tmp/chorusdb.dump" - tsds >> $logfile 2>&1
              echo "# Stop Internal Postgres..." >> $logfile 2>&1
              su -c "source /usr/local/tsds/chorus_path.sh && /usr/local/tsds/chorus_control.sh stop postgres" - tsds >> $logfile 2>&1

              #Backup database.yml
              echo "# Backup database.yml to database.yml.old..." >> $logfile 2>&1
              su -c "mv /usr/local/tsds/shared/database.yml /usr/local/tsds/shared/database.yml.old" - tsds
              su -c "touch /usr/local/tsds/shared/database.yml" - tsds
              su -c "chmod 644 /usr/local/tsds/shared/database.yml"

              # Reconfigure database.yml to point to Amazon RDS
              echo "# Creating new database.yml with RDS information..." >> $logfile 2>&1
              cat >> /usr/local/tsds/shared/database.yml <<EOF
              production:
                adapter: jdbcpostgresql
                encoding: unicode
                database: chorus
                username: "${RDSUsername}"
                password: "${RDSPassword}"
                min_messages: warning
                host: ${TSDSDBCluster.Endpoint.Address}
                port: '8543'
                pool: 40
            EOF

              #update .pgpass
              echo "# Updaing .pgpass with RDS information..." >> $logfile 2>&1
              su -c "mv /usr/local/tsds/.pgpass /usr/local/tsds/.pgpass_old" - tsds
              su -c "touch /usr/local/tsds/.pgpass" - tsds
              echo "*:*:*:${RDSUsername}:${RDSPassword}" >> /usr/local/tsds/.pgpass
              su -c "chmod 400 /usr/local/tsds/.pgpass" - tsds

              # restore postgres
              echo "# Restore Internal Postgres to RDS..." >> $logfile 2>&1
              su -c "/usr/local/tsds/current/postgres/bin/createdb chorus -p 8543 -h ${TSDSDBCluster.Endpoint.Address} -U postgres_chorus" - tsds >> $logfile 2>&1
              su -c "source /usr/local/tsds/chorus_path.sh && /usr/local/tsds/current/postgres/bin/pg_restore -d chorus -p 8543 -h ${TSDSDBCluster.Endpoint.Address} -U postgres_chorus /tmp/chorusdb.dump" >> $logfile 2>&1

              # Start TSDS
              echo "# Start TIBCO SDS..." >> $logfile 2>&1
              su -c "source /usr/local/tsds/chorus_path.sh && /usr/local/tsds/chorus_control.sh restart" - tsds >> $logfile 2>&1

              # Create a file to signal first node has been created
              echo "# Marking this as first node..." >> $logfile 2>&1
              su -c "touch /usr/local/tsds/.nodenum" - tsds
              echo "1" >> /usr/local/tsds/.nodenum
              su -c "chmod 777 /usr/local/tsds/.nodenum" - tsds

              # Sends signal back to CF for completion
              echo "# Sending signal back to CF..." >> $logfile 2>&1
              curl -X PUT -H 'Content-Type:' --data-binary '{"Status" : "SUCCESS","Reason" : "Configuration Complete","UniqueId" : "ID1234","Data" : "Application has completed configuration."}' "${TSDSInstanceWaitHandle}" >> $logfile 2>&1
            }

            echo "Load second_run function" >> $logfile 2>&1
            second_run() {
              # Start TSDS
              echo "# File Found.  Identified as additional node. Running second_run" >> $logfile 2>&1
              echo "# Starting TIBCO SDS..." >> $logfile 2>&1
              su -c "source /usr/local/tsds/chorus_path.sh && /usr/local/tsds/chorus_control.sh restart" - tsds
            }

            #DEBUG
            echo "# Entering Conditional Statement..." >> $logfile 2>&1
            if [ ! -f /usr/local/tsds/.nodenum ]; then
              echo "# Entering First Run Fucntion..." >> $logfile 2>&1
              first_run
            else
              echo "# Entering Second Run Function...">> $logfile 2>&1
              second_run
            fi

            echo "# Done: Configuration Successful" >> $logfile 2>&1
  TSDSInstanceWaitHandle:
    Type: 'AWS::CloudFormation::WaitConditionHandle'
    Properties: {}
  TSDSInitWaitCondition:
    Type: 'AWS::CloudFormation::WaitCondition'
    Properties:
      Handle: !Ref TSDSInstanceWaitHandle
      Timeout: '5400'
  AutoScalingGroup:
    Type: 'AWS::AutoScaling::AutoScalingGroup'
    DependsOn:
    - MountTarget1
    - MountTarget2
    - ApplicationLoadBalancer
    Properties:
      VPCZoneIdentifier:
      - !Ref PrivateSubnet1ID
      - !Ref PrivateSubnet2ID
      TargetGroupARNs:
        - !Ref ALBTargetGroupTSDSUI
      HealthCheckType: EC2
      HealthCheckGracePeriod: 90
      LaunchConfigurationName: !Ref LaunchConfiguration
      MinSize: '1'
      MaxSize: '1'
      DesiredCapacity: '1'
      Tags:
      - Key: Name
        Value: !Ref TSDSInstanceName
        PropagateAtLaunch: 'true'
      - Key: Owner
        Value: !Ref TSDSowner
        PropagateAtLaunch: 'true'
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MinInstancesInService: '0'
        MaxBatchSize: '1'
  TSDSFileSystem:
    Type: 'AWS::EFS::FileSystem'
    Properties:
      FileSystemTags:
      - Key: Name
        Value: TSDSFileSystem
  MountTarget1:
    Type: 'AWS::EFS::MountTarget'
    Properties:
      FileSystemId: !Ref TSDSFileSystem
      SubnetId: !Ref PrivateSubnet1ID
      SecurityGroups:
      - !Ref MountTargetSecurityGroup
  MountTarget2:
    Type: 'AWS::EFS::MountTarget'
    Properties:
      FileSystemId: !Ref TSDSFileSystem
      SubnetId: !Ref PrivateSubnet2ID
      SecurityGroups:
      - !Ref MountTargetSecurityGroup
  ApplicationLoadBalancer:
    Type: 'AWS::ElasticLoadBalancingV2::LoadBalancer'
    Properties:
      Scheme: internet-facing
      Subnets:
        - !Ref PrivateSubnet1ID
        - !Ref PrivateSubnet2ID
      SecurityGroups:
        - Ref: TSDSELBSecurityGroup
  ALBTargetGroupTSDSUI:
    Type: 'AWS::ElasticLoadBalancingV2::TargetGroup'
    Properties:
      HealthCheckIntervalSeconds: 30
      HealthyThresholdCount: 5
      Port: '8080'
      Protocol: HTTP
      UnhealthyThresholdCount: 5
      VpcId:
        Ref: VPCID
  ELBListenerTSDSUI:
    Type: 'AWS::ElasticLoadBalancingV2::Listener'
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn:
            Ref: ALBTargetGroupTSDSUI
      LoadBalancerArn:
        Ref: ApplicationLoadBalancer
      Port: '8080'
      Protocol: HTTP
Outputs:
  TSDSRestApiURL:
    Description: URL for Elastic Load Balancer to connect to TSDS 6.4
    Value:
      Fn::Sub: ${ApplicationLoadBalancer.DNSName}:8080
